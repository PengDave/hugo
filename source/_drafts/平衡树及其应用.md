---
title: 平衡树及其应用
author: PengDave
tags:
---

# 前置

二叉搜索树（知道概念即可）

# fhq treap

## 基础思想

对于一棵二叉搜索树，如果插入数据随机，则树高期望为  $O(\log{n})$ 级别。但我们很容易构造数据来使二叉搜索树变成链。因此我们需要方法来调整树的平衡。此时 treap 就是一个不错的方法。在 treap 中，我们给每个节点额外添加一个随机值 $pri$，在满足二叉搜索树的性质时我们也要使 $pri$ 符合堆的性质（以下代码和图都采用大根堆），可以证明，该方法的期望树高为 $O(\log{n})$。下图便是 treap 的一个示例（括号中为附加权值）：

![](https://cdn.luogu.com.cn/upload/image_hosting/uo6x1x38.png)

## 基本操作

### 分裂

分裂指将平衡树按照大小或排名分成两部分，下图为按照权值  $6$ 分裂的示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pepk3o2z.png)

分裂可采用递归实现，代码如下：

```cpp
//按权值分
void splitval(int rt,int x,int &u,int &v){
    if(!rt){u=v=0;return;}
    if(val[rt]<=x){
        split(rc[rt],x,rc[rt],v);
        u=rt;
    }else{
        split(lc[rt],x,u,lc[rt]);
        v=rt;
    }
    pushup(rt);
    return;
}
//按排名分
void splitsiz(int u,int x,int &L,int &R){
    if(!u){L=R=0;return;}
    pushdown(u);
    if(x<=siz[lc[u]]){
        R=u;split(lc[u],x,L,lc[u]);pushup(u);
    }else{
        L=u;split(rc[u],x-siz[lc[u]]-1,rc[u],R);pushup(u);
    }
    return;
}
```

### 合并

合并也很简单，就是将两棵平衡树合在一起

```cpp
int Merge(int u,int v){
    if(!u||!v)return u|v;
    if(pri[u]>pri[v]){//u比v优先级高
        rc[u]=Merge(rc[u],v);//将v合并在u右子树上
        pushup(u);return u;
    }else{//v比u优先级高
        lc[v]=Merge(u,lc[v]);//将u合并在v左子树上
        pushup(v);return v;
    }
}
```

## 维护有序集合

### 插入

很简单，将树按权值分裂，再将新的点合进去就行了。

```cpp
void newnode(int x){
    idx++;
    val[idx]=x;siz[idx]=1;pri[idx]=rnd();lc[idx]=rc[idx]=0;
    return;
}
void insert(int x){
    int u,v;
    split(Root,x,u,v);
    newnode(x);
    Root=Merge(Merge(u,idx),v);
    return;
}
```

### 删除

将要删除的点分裂出来再将其他部分合并即可

```cpp
void del(int x){
    int L,M,R;
    split(Root,x,L,R);
    split(L,x-1,L,M);
    M=Merge(lc[M],rc[M]);
    Root=Merge(Merge(L,M),R);
    return;
}
```

### 查排名

将比要查的数小的分裂出来算子树大小即可

```cpp
int Rank(int x){
    int u,v;
    split(Root,x-1,u,v);
    int ans=siz[u]+1;
    Root=Merge(u,v);
    return ans;
}
```

### 求第 k 值

递归求解即可

```cpp
int kth(int u,int k){
    if(k<=siz[lc[u]])return kth(lc[u],k);
    else if(k==siz[lc[u]]+1)return val[u];
    else return kth(rc[u],k-siz[lc[u]]-1);
}
```

### 前驱后继

都很简单，看代码即可

```cpp
int pre(int x){
    int u,v;
    split(Root,x-1,u,v);
    int ans=kth(u,siz[u]);
    Root=Merge(u,v);
    return ans;
}
int suf(int x){
    int u,v;
    split(Root,x,u,v);
    int ans=kth(v,1);
    Root=Merge(u,v);
    return ans;
}
```

### 完整代码

```cpp
#include<iostream>
#include<random>
#include<cstdio>
using namespace std;
const int N=1e5+10;
int val[N],siz[N],lc[N],rc[N],idx;int n;unsigned pri[N];
mt19937 rnd(random_device{}());
#define pushup(u) siz[u]=siz[lc[u]]+siz[rc[u]]+1
void split(int rt,int x,int &u,int &v){
    if(!rt){u=v=0;return;}
    if(val[rt]<=x){
        split(rc[rt],x,rc[rt],v);
        u=rt;
    }else{
        split(lc[rt],x,u,lc[rt]);
        v=rt;
    }
    pushup(rt);
    return;
}
int Merge(int u,int v){
    if(!u||!v)return u|v;
    if(pri[u]>pri[v]){
        rc[u]=Merge(rc[u],v);
        pushup(u);return u;
    }else{
        lc[v]=Merge(u,lc[v]);
        pushup(v);return v;
    }
}
int Root=0;
void newnode(int x){
    idx++;
    val[idx]=x;siz[idx]=1;pri[idx]=rnd();lc[idx]=rc[idx]=0;
    return;
}
void insert(int x){
    int u,v;
    split(Root,x,u,v);
    newnode(x);
    Root=Merge(Merge(u,idx),v);
    return;
}
void del(int x){
    int L,M,R;
    split(Root,x,L,R);
    split(L,x-1,L,M);
    M=Merge(lc[M],rc[M]);
    Root=Merge(Merge(L,M),R);
    return;
}
int Rank(int x){
    int u,v;
    split(Root,x-1,u,v);
    int ans=siz[u]+1;
    Root=Merge(u,v);
    return ans;
}
int kth(int u,int k){
    if(k<=siz[lc[u]])return kth(lc[u],k);
    else if(k==siz[lc[u]]+1)return val[u];
    else return kth(rc[u],k-siz[lc[u]]-1);
}
int pre(int x){
    int u,v;
    split(Root,x-1,u,v);
    int ans=kth(u,siz[u]);
    Root=Merge(u,v);
    return ans;
}
int suf(int x){
    int u,v;
    split(Root,x,u,v);
    int ans=kth(v,1);
    Root=Merge(u,v);
    return ans;
}
void dbg(int u){
    if(!u)return;
    dbg(lc[u]);
    cout<<val[u]<<" ";
    dbg(rc[u]);
    return;
}
int main(){
    cin.tie(0);ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        int opt,x;
        cin>>opt>>x;
        if(opt==1)insert(x);
        if(opt==2)del(x);
        if(opt==3)cout<<Rank(x)<<'\n';
        if(opt==4)cout<<kth(Root,x)<<'\n';
        if(opt==5)cout<<pre(x)<<'\n';
        if(opt==6)cout<<suf(x)<<'\n';
        // dbg(Root);cout<<'\n';
    }
    return 0;
}
```



## 维护区间

我们使平衡树的中序遍历为序列的顺序，将要处理的区间每次分裂出来进行修改打标记，注意别忘了下传标记。

### P3391 【模板】文艺平衡树

维护翻转标记即可

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<random>
#include<ctime>
using namespace std;
const int N=1e5+10;
int n,m;
mt19937 rnd(time(0));
int lc[N],rc[N],val[N],siz[N],tag[N],tot;unsigned pri[N];
#define pushup(u) siz[u]=siz[lc[u]]+siz[rc[u]]+1
void pushdown(int u){
    if(tag[u]){
        swap(lc[u],rc[u]);
        tag[lc[u]]^=1;tag[rc[u]]^=1;
        tag[u]=0;
    }
    return;
}
void split(int u,int x,int &L,int &R){
    if(!u){L=R=0;return;}
    pushdown(u);
    if(x<=siz[lc[u]]){
        R=u;split(lc[u],x,L,lc[u]);pushup(u);
    }else{
        L=u;split(rc[u],x-siz[lc[u]]-1,rc[u],R);pushup(u);
    }
    return;
}
int Merge(int u,int v){
    if(!u||!v)return u|v;
    pushdown(u);
    pushdown(v);
    if(pri[u]>pri[v]){
        rc[u]=Merge(rc[u],v);pushup(u);return u;
    }else{
        lc[v]=Merge(u,lc[v]);pushup(v);return v;
    }
}
int newnode(int x){
    tot++;val[tot]=x;siz[tot]=1;pri[tot]=rnd();tag[tot]=lc[tot]=rc[tot]=0;
    return tot;
}
int root=0;
void print(int u){
    if(!u)return;
    pushdown(u);
    print(lc[u]);
    cout<<val[u]<<' ';
    print(rc[u]);
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int u=newnode(i);
        root=Merge(root,u);
    }
    for(int i=1;i<=m;i++){
        int l,r;
        cin>>l>>r;
        int L,R,M;
        split(root,r,L,R);
        split(L,l-1,L,M);
        tag[M]^=1;
        root=Merge(Merge(L,M),R);
    }
    print(root);
    return 0;
}
```

